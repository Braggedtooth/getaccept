/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * GetAccept
 * GetAccept provides a sales enablement platform for sales to design, send, promote, track, and e-sign sales documents, leveraging sales collateral, contract management, proposals, and electronic signatures in one place.
 *
 * OpenAPI spec version: 1.6
 * Contact: integrations@getaccept.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.getaccept.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Authentication model
 * @export
 * @interface AuthBody
 */
export interface AuthBody {
    /**
     * This is the email of the user in GetAccept
     * @type {string}
     * @memberof AuthBody
     */
    email: string;
    /**
     * This is the password of the user in GetAccept
     * @type {string}
     * @memberof AuthBody
     */
    password: string;
    /**
     * This specifies what entity to select if multiple entities are available for a user. If no value is specified the default entity will be selected.
     * @type {string}
     * @memberof AuthBody
     */
    entityId?: string;
    /**
     * The client id of your app if you received one from our API team
     * @type {string}
     * @memberof AuthBody
     */
    clientId?: string;
}
/**
 * Every unique e-mail address (or mobile number) is defined as a contact.
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * Contact ID
     * @type {string}
     * @memberof Contact
     */
    contactId?: string;
    /**
     * Full name of the contact
     * @type {string}
     * @memberof Contact
     */
    fullname?: string;
    /**
     * First name of the contact
     * @type {string}
     * @memberof Contact
     */
    firstName?: string;
    /**
     * Last name of the contact
     * @type {string}
     * @memberof Contact
     */
    lastName?: string;
    /**
     * Title of the contact
     * @type {string}
     * @memberof Contact
     */
    title?: string;
    /**
     * Mobile number of the contact
     * @type {string}
     * @memberof Contact
     */
    mobile?: string;
    /**
     * Name of the created document
     * @type {string}
     * @memberof Contact
     */
    email?: string;
    /**
     * Thumb URL of the contact
     * @type {string}
     * @memberof Contact
     */
    thumbUrl?: string;
    /**
     * Note of the contact
     * @type {string}
     * @memberof Contact
     */
    note?: string;
    /**
     * Gender of the recipient
     * @type {string}
     * @memberof Contact
     */
    gender?: string;
    /**
     * Number of documents for a contact
     * @type {number}
     * @memberof Contact
     */
    documentCount?: number;
    /**
     * Company ID
     * @type {string}
     * @memberof Contact
     */
    companyId?: string;
    /**
     * Company name of the contact
     * @type {string}
     * @memberof Contact
     */
    companyName?: string;
    /**
     * Company number of the contact
     * @type {string}
     * @memberof Contact
     */
    companyNumber?: string;
    /**
     * Company logo
     * @type {string}
     * @memberof Contact
     */
    companyLogoUrl?: string;
    /**
     * Date of created contact
     * @type {string}
     * @memberof Contact
     */
    createdAt?: string;
}
/**
 * Contact list
 * @export
 * @interface Contacts
 */
export interface Contacts {
    /**
     * 
     * @type {Array<Contact>}
     * @memberof Contacts
     */
    contacts?: Array<Contact>;
}
/**
 * 
 * @export
 * @interface ContactsBody
 */
export interface ContactsBody {
    /**
     * Use to specify full name instead of first/last name
     * @type {string}
     * @memberof ContactsBody
     */
    fullname?: string;
    /**
     * First name of the contact
     * @type {string}
     * @memberof ContactsBody
     */
    firstName?: string;
    /**
     * Last name of the contact
     * @type {string}
     * @memberof ContactsBody
     */
    lastName?: string;
    /**
     * Email address of the contact
     * @type {string}
     * @memberof ContactsBody
     */
    email?: string;
    /**
     * The title of the contact, ex. CEO, Sales manager
     * @type {string}
     * @memberof ContactsBody
     */
    title?: string;
    /**
     * Phone number in international format
     * @type {string}
     * @memberof ContactsBody
     */
    phone?: string;
    /**
     * Mobile number in international format
     * @type {string}
     * @memberof ContactsBody
     */
    mobile?: string;
    /**
     * Optional internal note for contact
     * @type {string}
     * @memberof ContactsBody
     */
    note?: string;
    /**
     * Associated company name
     * @type {string}
     * @memberof ContactsBody
     */
    companyName?: string;
    /**
     * Associated company number
     * @type {string}
     * @memberof ContactsBody
     */
    companyNumber?: string;
}
/**
 * A document is one or multiple uploaded file(s) that is to be sent to one or many recipients created by a user.
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * ID of the sender user
     * @type {string}
     * @memberof Document
     */
    userId?: string;
    /**
     * Email subject text
     * @type {string}
     * @memberof Document
     */
    emailSendSubject?: string;
    /**
     * If the document has been signed
     * @type {boolean}
     * @memberof Document
     */
    isSigned?: boolean;
    /**
     * Name of document
     * @type {string}
     * @memberof Document
     */
    name?: string;
    /**
     * Value of document
     * @type {number}
     * @memberof Document
     */
    value?: number;
    /**
     * If the document is private
     * @type {boolean}
     * @memberof Document
     */
    isPrivate?: boolean;
    /**
     * Current status of document
     * @type {string}
     * @memberof Document
     */
    status?: string;
    /**
     * Document send date
     * @type {string}
     * @memberof Document
     */
    sendDate?: string;
    /**
     * Document sign date
     * @type {string}
     * @memberof Document
     */
    signDate?: string;
    /**
     * If the document has scheduled sending
     * @type {boolean}
     * @memberof Document
     */
    isScheduledSending?: boolean;
    /**
     * If transfer of signing rights is enabled
     * @type {boolean}
     * @memberof Document
     */
    isSigningForward?: boolean;
    /**
     * Thumb image of sender user
     * @type {string}
     * @memberof Document
     */
    senderThumbUrl?: string;
    /**
     * Automatic chat text
     * @type {string}
     * @memberof Document
     */
    autoCommentText?: string;
    /**
     * Thumb image of document
     * @type {string}
     * @memberof Document
     */
    thumbUrl?: string;
    /**
     * Document tags
     * @type {string}
     * @memberof Document
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    emailSendTemplateId?: string;
    /**
     * Sending email message
     * @type {string}
     * @memberof Document
     */
    emailSendMessage?: string;
    /**
     * If automatic chat comment is enabled
     * @type {boolean}
     * @memberof Document
     */
    isAutoComment?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Document
     */
    isSigningInitials?: boolean;
    /**
     * Name of sender user
     * @type {string}
     * @memberof Document
     */
    senderName?: string;
    /**
     * ID of previous document version
     * @type {string}
     * @memberof Document
     */
    parentId?: string;
    /**
     * ID in external editor
     * @type {string}
     * @memberof Document
     */
    externalEditorId?: string;
    /**
     * Company Name
     * @type {string}
     * @memberof Document
     */
    companyName?: string;
    /**
     * If automatic chat email is enabled
     * @type {boolean}
     * @memberof Document
     */
    isAutoCommentEmail?: boolean;
    /**
     * URL to download signed document
     * @type {string}
     * @memberof Document
     */
    downloadUrl?: string;
    /**
     * Document expiration date
     * @type {string}
     * @memberof Document
     */
    expirationDate?: string;
    /**
     * When the document was scheduled for sending
     * @type {string}
     * @memberof Document
     */
    scheduledSendingTime?: string;
    /**
     * When document was created
     * @type {string}
     * @memberof Document
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    externalId?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    externalEditorType?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    companyLogoUrl?: string;
    /**
     * Unique ID for document
     * @type {number}
     * @memberof Document
     */
    uniqueId?: number;
    /**
     * If the document has a introduction video
     * @type {boolean}
     * @memberof Document
     */
    isVideo?: boolean;
    /**
     * If document has identify recipient enabled
     * @type {boolean}
     * @memberof Document
     */
    isIdentifyRecipient?: boolean;
    /**
     * Email address of sender user
     * @type {string}
     * @memberof Document
     */
    senderEmail?: string;
    /**
     * If document is signable
     * @type {boolean}
     * @memberof Document
     */
    isSigning?: boolean;
    /**
     * Document type
     * @type {string}
     * @memberof Document
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    externalClientId?: string;
    /**
     * Company ID
     * @type {string}
     * @memberof Document
     */
    companyId?: string;
    /**
     * If document has been self-signed by sender
     * @type {boolean}
     * @memberof Document
     */
    isSelfsign?: boolean;
    /**
     * If handwritten signature is enabled
     * @type {boolean}
     * @memberof Document
     */
    isSigningBiometric?: boolean;
    /**
     * If recipient signing order is enabled
     * @type {boolean}
     * @memberof Document
     */
    isSigningOrder?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    autoCommentEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    entityAutoCommentText?: string;
    /**
     * Number of fields in document
     * @type {number}
     * @memberof Document
     */
    fieldCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    companyNumber?: string;
    /**
     * If automatic reminders are enabled
     * @type {boolean}
     * @memberof Document
     */
    isReminderSending?: boolean;
    /**
     * Link to internal preview of document
     * @type {string}
     * @memberof Document
     */
    previewUrl?: string;
    /**
     * 
     * @type {Array<Recipient>}
     * @memberof Document
     */
    recipients?: Array<Recipient>;
}
/**
 * 
 * @export
 * @interface DocumentIdSealBody
 */
export interface DocumentIdSealBody {
    /**
     * Use this to specify the sender user/owner by id to be used for self-signing the document.
     * @type {string}
     * @memberof DocumentIdSealBody
     */
    senderId?: string;
    /**
     * Use this to specify the sender user/owner by email address to be used for self-signing the document.
     * @type {string}
     * @memberof DocumentIdSealBody
     */
    senderEmail?: string;
}
/**
 * 
 * @export
 * @interface DocumentIdSendBody
 */
export interface DocumentIdSendBody {
    /**
     * Use this to specify the sender user/owner by id to be used for self-signing the document.
     * @type {string}
     * @memberof DocumentIdSendBody
     */
    senderId?: string;
    /**
     * Use this to specify the sender user/owner by email address to be used for self-signing the document.
     * @type {string}
     * @memberof DocumentIdSendBody
     */
    senderEmail?: string;
}
/**
 * Document list
 * @export
 */
export type Documents = Array<DocumentsInner>
/**
 * 
 * @export
 * @interface DocumentsAttachments
 */
export interface DocumentsAttachments {
    /**
     * file or external where file is an uploaded file and external is a link to an external file
     * @type {string}
     * @memberof DocumentsAttachments
     */
    type?: DocumentsAttachments.TypeEnum;
    /**
     * Attachment ID received from list or after upload
     * @type {string}
     * @memberof DocumentsAttachments
     */
    id?: string;
    /**
     * Require that recipient view the attachment
     * @type {boolean}
     * @memberof DocumentsAttachments
     */
    requireView?: boolean;
}

/**
 * @export
 * @namespace DocumentsAttachments
 */
export namespace DocumentsAttachments {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        File = <any> 'file',
        External = <any> 'external'
    }
}
/**
 * 
 * @export
 * @interface DocumentsBody
 */
export interface DocumentsBody {
    /**
     * Enter a name of the document
     * @type {string}
     * @memberof DocumentsBody
     */
    name: string;
    /**
     * Select a template to use for the sending
     * @type {string}
     * @memberof DocumentsBody
     */
    templateId?: string;
    /**
     * Set the type/category of the document
     * @type {string}
     * @memberof DocumentsBody
     */
    type?: DocumentsBody.TypeEnum;
    /**
     * Value of deal or document
     * @type {number}
     * @memberof DocumentsBody
     */
    value?: number;
    /**
     * Send from other user than authenticated
     * @type {string}
     * @memberof DocumentsBody
     */
    senderId?: string;
    /**
     * Send from other email than authenticated user
     * @type {string}
     * @memberof DocumentsBody
     */
    senderEmail?: string;
    /**
     * Sign document using recipient initials
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isSigningInitials?: boolean;
    /**
     * Should automatic reminders be sent
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isReminderSending?: boolean;
    /**
     * If the document should be sent after creation
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isAutomaticSending?: boolean;
    /**
     * Select a video to use for the sending
     * @type {string}
     * @memberof DocumentsBody
     */
    videoId?: string;
    /**
     * Attachments
     * @type {Array<DocumentsAttachments>}
     * @memberof DocumentsBody
     */
    attachments?: Array<DocumentsAttachments>;
    /**
     * Should the document be sent for signing
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isSigning?: boolean;
    /**
     * Should the document be sent to recipient mobile by text
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isSmsSending?: boolean;
    /**
     * Comma-separated, unique file-ids received when uploading files
     * @type {string}
     * @memberof DocumentsBody
     */
    fileIds?: string;
    /**
     * Filename of the document, with the extension. This will be helpful for converting different file-types.
     * @type {string}
     * @memberof DocumentsBody
     */
    fileName?: string;
    /**
     * Base64 encoded file content
     * @type {string}
     * @memberof DocumentsBody
     */
    fileContent?: string;
    /**
     * Url to document file. Documents must be public available for download
     * @type {string}
     * @memberof DocumentsBody
     */
    fileUrl?: string;
    /**
     * Should recipients be able to transfer signature rights
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isSigningForward?: boolean;
    /**
     * 
     * @type {Array<DocumentsRecipients>}
     * @memberof DocumentsBody
     */
    recipients?: Array<DocumentsRecipients>;
    /**
     * Use handwritten signature
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isSigningBiometric?: boolean;
    /**
     * Date and time when the document should expire
     * @type {Date}
     * @memberof DocumentsBody
     */
    expirationDate?: Date;
    /**
     * Should the sending be scheduled for sending in the future
     * @type {boolean}
     * @memberof DocumentsBody
     */
    isScheduledSending?: boolean;
    /**
     * Date and time when the document should be sent out
     * @type {Date}
     * @memberof DocumentsBody
     */
    scheduledSendingTime?: Date;
    /**
     * Custom field
     * @type {Array<DocumentsCustomFields>}
     * @memberof DocumentsBody
     */
    customFields?: Array<DocumentsCustomFields>;
    /**
     * External system ID for identification
     * @type {string}
     * @memberof DocumentsBody
     */
    externalId?: string;
}

/**
 * @export
 * @namespace DocumentsBody
 */
export namespace DocumentsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Sales = <any> 'sales',
        Introduction = <any> 'introduction',
        Hr = <any> 'hr',
        Other = <any> 'other'
    }
}
/**
 * 
 * @export
 * @interface DocumentsCustomFields
 */
export interface DocumentsCustomFields {
    /**
     * ID of custom template field
     * @type {string}
     * @memberof DocumentsCustomFields
     */
    id?: string;
    /**
     * Name of custom template field
     * @type {string}
     * @memberof DocumentsCustomFields
     */
    name?: string;
    /**
     * Value of custom template field
     * @type {string}
     * @memberof DocumentsCustomFields
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface DocumentsInner
 */
export interface DocumentsInner {
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof DocumentsInner
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    senderThumb?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    senderName?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentsInner
     */
    isSigning?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    companyName?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    expirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentsInner
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentsInner
     */
    isPrivate?: boolean;
}
/**
 * 
 * @export
 * @interface DocumentsRecipients
 */
export interface DocumentsRecipients {
    /**
     * Recipient first name
     * @type {string}
     * @memberof DocumentsRecipients
     */
    firstName?: string;
    /**
     * Last name of recipient
     * @type {string}
     * @memberof DocumentsRecipients
     */
    lastName?: string;
    /**
     * The kind of recipient in the document
     * @type {string}
     * @memberof DocumentsRecipients
     */
    role?: DocumentsRecipients.RoleEnum;
    /**
     * The name of the role in a template
     * @type {string}
     * @memberof DocumentsRecipients
     */
    roleName?: string;
    /**
     * Should a question be asked before signing
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifyQnaSign?: boolean;
    /**
     * Question to ask for verification
     * @type {string}
     * @memberof DocumentsRecipients
     */
    verifyQnaQuestion?: string;
    /**
     * Should a question be asked
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifyQna?: boolean;
    /**
     * Company name of the recipient
     * @type {string}
     * @memberof DocumentsRecipients
     */
    companyName?: string;
    /**
     * Company number of the recipient
     * @type {string}
     * @memberof DocumentsRecipients
     */
    companyNumber?: string;
    /**
     * Should question be asked before opening document
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifyQnaOpen?: boolean;
    /**
     * The answer to question
     * @type {string}
     * @memberof DocumentsRecipients
     */
    verifyQnaAnswer?: string;
    /**
     * Should a SMS verify the recipient before signing
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifySmsSign?: boolean;
    /**
     * EID type to be used for personal verification
     * @type {string}
     * @memberof DocumentsRecipients
     */
    verifyEidType?: string;
    /**
     * Additional note for a recipient
     * @type {string}
     * @memberof DocumentsRecipients
     */
    note?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof DocumentsRecipients
     */
    email?: string;
    /**
     * Mobile phone in international format
     * @type {string}
     * @memberof DocumentsRecipients
     */
    mobile?: string;
    /**
     * Verify recipient by SMS
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifySms?: boolean;
    /**
     * Verify SMS on open
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifySmsOpen?: boolean;
    /**
     * If signing order is enabled
     * @type {number}
     * @memberof DocumentsRecipients
     */
    orderNum?: number;
    /**
     * Verify using EID
     * @type {boolean}
     * @memberof DocumentsRecipients
     */
    verifyEid?: boolean;
}

/**
 * @export
 * @namespace DocumentsRecipients
 */
export namespace DocumentsRecipients {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Signer = <any> 'signer',
        Approver = <any> 'approver',
        Cc = <any> 'cc'
    }
}
/**
 * 
 * @export
 * @interface EventsRejectedBody
 */
export interface EventsRejectedBody {
    /**
     * Event trigger
     * @type {string}
     * @memberof EventsRejectedBody
     */
    event: string;
    /**
     * The URL to post payload to on event
     * @type {string}
     * @memberof EventsRejectedBody
     */
    targetUrl: string;
    /**
     * The host name to send the post to
     * @type {string}
     * @memberof EventsRejectedBody
     */
    host?: string;
    /**
     * Additional payload data to post
     * @type {string}
     * @memberof EventsRejectedBody
     */
    payload?: string;
    /**
     * If the webhook should catch events for all entity users.
     * @type {boolean}
     * @memberof EventsRejectedBody
     */
    global?: boolean;
    /**
     * If the event fails, send a notification to this email instead of the sender
     * @type {string}
     * @memberof EventsRejectedBody
     */
    notificationEmail?: string;
}
/**
 * 
 * @export
 * @interface EventsReviewedBody
 */
export interface EventsReviewedBody {
    /**
     * Event trigger
     * @type {string}
     * @memberof EventsReviewedBody
     */
    event: string;
    /**
     * The URL to post payload to on event
     * @type {string}
     * @memberof EventsReviewedBody
     */
    targetUrl: string;
    /**
     * The host name to send the post to
     * @type {string}
     * @memberof EventsReviewedBody
     */
    host?: string;
    /**
     * Additional payload data to post
     * @type {string}
     * @memberof EventsReviewedBody
     */
    payload?: string;
    /**
     * If the webhook should catch events for all entity users.
     * @type {boolean}
     * @memberof EventsReviewedBody
     */
    global?: boolean;
    /**
     * If the event fails, send a notification to this email instead of the sender
     * @type {string}
     * @memberof EventsReviewedBody
     */
    notificationEmail?: string;
}
/**
 * 
 * @export
 * @interface EventsSignedBody
 */
export interface EventsSignedBody {
    /**
     * Event trigger
     * @type {string}
     * @memberof EventsSignedBody
     */
    event: string;
    /**
     * The URL to post payload to on event
     * @type {string}
     * @memberof EventsSignedBody
     */
    targetUrl: string;
    /**
     * The host name to send the post to
     * @type {string}
     * @memberof EventsSignedBody
     */
    host?: string;
    /**
     * Additional payload data to post
     * @type {string}
     * @memberof EventsSignedBody
     */
    payload?: string;
    /**
     * If the webhook should catch events for all entity users.
     * @type {boolean}
     * @memberof EventsSignedBody
     */
    global?: boolean;
    /**
     * If the event fails, send a notification to this email instead of the sender
     * @type {string}
     * @memberof EventsSignedBody
     */
    notificationEmail?: string;
}
/**
 * Field details
 * @export
 * @interface Field
 */
export interface Field {
}
/**
 * Field list
 * @export
 * @interface Fields
 */
export interface Fields {
    /**
     * 
     * @type {Array<Field>}
     * @memberof Fields
     */
    fields?: Array<Field>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Token to be used in consequtive requests using bearer header
     * @type {string}
     * @memberof InlineResponse200
     */
    accessToken?: string;
    /**
     * Seconds until the access token expires
     * @type {number}
     * @memberof InlineResponse200
     */
    expiresIn?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    accessToken?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    expiresIn?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * ID of the uploaded video to be used in video_id when creating a document
     * @type {string}
     * @memberof InlineResponse20010
     */
    videoId?: string;
    /**
     * File name of the video
     * @type {string}
     * @memberof InlineResponse20010
     */
    filename?: string;
    /**
     * Status of the video
     * @type {string}
     * @memberof InlineResponse20010
     */
    fileStatus?: string;
    /**
     * Id of the processing job converting and compressing the video. Poll for job status updates using /video/job/<ID>.
     * @type {string}
     * @memberof InlineResponse20010
     */
    jobId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array<InlineResponse20011Attachments>}
     * @memberof InlineResponse20011
     */
    attachments?: Array<InlineResponse20011Attachments>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Attachments
 */
export interface InlineResponse20011Attachments {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Attachments
     */
    attachmentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Attachments
     */
    attachmentType?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Attachments
     */
    attachmentTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Attachments
     */
    attachmentUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20011Attachments
     */
    published?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20011Attachments
     */
    library?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<InlineResponse2002Templates>}
     * @memberof InlineResponse2002
     */
    templates?: Array<InlineResponse2002Templates>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Templates
 */
export interface InlineResponse2002Templates {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002Templates
     */
    isPrivate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Templates
     */
    roleCount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    thumbUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    videoId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    videoThumbUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    externalEditorType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002Templates
     */
    isEditable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Templates
     */
    pageCount?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002Templates
     */
    fieldCount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    senderName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Templates
     */
    senderThumbUrl?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<InlineResponse2003Videos>}
     * @memberof InlineResponse2003
     */
    videos?: Array<InlineResponse2003Videos>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Videos
 */
export interface InlineResponse2003Videos {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Videos
     */
    videoId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Videos
     */
    videoType?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Videos
     */
    videoTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Videos
     */
    videoUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Videos
     */
    thumbUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Videos
     */
    saved?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Videos
     */
    published?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Videos
     */
    editable?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    documentUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    file?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<InlineResponse2005Roles>}
     * @memberof InlineResponse2005
     */
    roles?: Array<InlineResponse2005Roles>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005Roles
 */
export interface InlineResponse2005Roles {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    roleName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    mobile?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Roles
     */
    roleId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * ID of the created contact
     * @type {string}
     * @memberof InlineResponse2007
     */
    contactId?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * ID of the uploaded file to be used in file_ids when creating a document
     * @type {string}
     * @memberof InlineResponse2008
     */
    fileId?: string;
    /**
     * Status of the uploaded file
     * @type {string}
     * @memberof InlineResponse2008
     */
    fileStatus?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * ID of the uploaded attachment to be used in attachment_id when creating a document
     * @type {string}
     * @memberof InlineResponse2009
     */
    id?: string;
    /**
     * Type of the attachment
     * @type {string}
     * @memberof InlineResponse2009
     */
    type?: string;
    /**
     * Title of the attachment
     * @type {string}
     * @memberof InlineResponse2009
     */
    title?: string;
    /**
     * File name of the attachment
     * @type {string}
     * @memberof InlineResponse2009
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
}
/**
 * Every unique e-mail address (or mobile number) that is connected to a document is a recipient.
 * @export
 * @interface Recipient
 */
export interface Recipient {
    /**
     * Thumb URL of the recipient
     * @type {string}
     * @memberof Recipient
     */
    thumbUrl?: string;
    /**
     * ID of the recipient
     * @type {string}
     * @memberof Recipient
     */
    id?: string;
    /**
     * Full name of the recipient
     * @type {string}
     * @memberof Recipient
     */
    fullname?: string;
    /**
     * Last name of the recipient
     * @type {string}
     * @memberof Recipient
     */
    lastName?: string;
    /**
     * Email of the recipient
     * @type {string}
     * @memberof Recipient
     */
    email?: string;
    /**
     * Company name of the recipient
     * @type {string}
     * @memberof Recipient
     */
    companyName?: string;
    /**
     * Status of the recipient
     * @type {string}
     * @memberof Recipient
     */
    status?: string;
    /**
     * Mobile number of the recipient
     * @type {string}
     * @memberof Recipient
     */
    mobile?: string;
    /**
     * Unique URL for the recipient to view/sign
     * @type {string}
     * @memberof Recipient
     */
    documentUrl?: string;
    /**
     * First name of the recipient
     * @type {string}
     * @memberof Recipient
     */
    firstName?: string;
    /**
     * Company number of the recipient
     * @type {string}
     * @memberof Recipient
     */
    companyNumber?: string;
    /**
     * Title of the recipient
     * @type {string}
     * @memberof Recipient
     */
    title?: string;
    /**
     * Note of the recipient
     * @type {string}
     * @memberof Recipient
     */
    note?: string;
    /**
     * Signing order of the recipient
     * @type {string}
     * @memberof Recipient
     */
    orderNum?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipient
     */
    role?: string;
    /**
     * Gender of the recipient
     * @type {string}
     * @memberof Recipient
     */
    gender?: string;
}
/**
 * Recipient list
 * @export
 * @interface Recipients
 */
export interface Recipients {
    /**
     * 
     * @type {Array<Recipient>}
     * @memberof Recipients
     */
    recipients?: Array<Recipient>;
}
/**
 * Subscription details
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * ID of the subscription
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * ID of the subscription
     * @type {string}
     * @memberof Subscription
     */
    subscriptionId?: string;
    /**
     * Status of subscription
     * @type {number}
     * @memberof Subscription
     */
    status?: number;
    /**
     * Event
     * @type {string}
     * @memberof Subscription
     */
    event?: string;
    /**
     * Host
     * @type {string}
     * @memberof Subscription
     */
    host?: string;
    /**
     * Target URL
     * @type {string}
     * @memberof Subscription
     */
    targetUrl?: string;
    /**
     * Payload
     * @type {string}
     * @memberof Subscription
     */
    payload?: string;
    /**
     * Global
     * @type {boolean}
     * @memberof Subscription
     */
    global?: boolean;
    /**
     * Notification Email
     * @type {string}
     * @memberof Subscription
     */
    notificationEmail?: string;
    /**
     * Created
     * @type {string}
     * @memberof Subscription
     */
    createdAt?: string;
}
/**
 * Subscription list
 * @export
 */
export type Subscriptions = Array<Subscription>
/**
 * 
 * @export
 * @interface SubscriptionsBody
 */
export interface SubscriptionsBody {
    /**
     * Event trigger
     * @type {string}
     * @memberof SubscriptionsBody
     */
    event: SubscriptionsBody.EventEnum;
    /**
     * The URL to post payload to on event
     * @type {string}
     * @memberof SubscriptionsBody
     */
    targetUrl: string;
    /**
     * The host name to send the post to
     * @type {string}
     * @memberof SubscriptionsBody
     */
    host?: string;
    /**
     * Additional payload data to post
     * @type {string}
     * @memberof SubscriptionsBody
     */
    payload?: string;
    /**
     * If the webhook should catch events for all entity users.
     * @type {boolean}
     * @memberof SubscriptionsBody
     */
    global?: boolean;
    /**
     * If the event fails, send a notification to this email instead of the sender
     * @type {string}
     * @memberof SubscriptionsBody
     */
    notificationEmail?: string;
}

/**
 * @export
 * @namespace SubscriptionsBody
 */
export namespace SubscriptionsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum EventEnum {
        Created = <any> 'document.created',
        Sent = <any> 'document.sent',
        Viewed = <any> 'document.viewed',
        Reviewed = <any> 'document.reviewed',
        Signed = <any> 'document.signed',
        Approved = <any> 'document.approved',
        Expired = <any> 'document.expired',
        Rejected = <any> 'document.rejected',
        Downloaded = <any> 'document.downloaded',
        Printed = <any> 'document.printed',
        Forwarded = <any> 'document.forwarded',
        PartiallySigned = <any> 'document.partially_signed',
        Commented = <any> 'document.commented',
        Hardbounced = <any> 'document.hardbounced',
        Imported = <any> 'document.imported'
    }
}
/**
 * 
 * @export
 * @interface UploadAttachmentBody
 */
export interface UploadAttachmentBody {
    /**
     * Filename of the document, with the extension. This will be helpful for converting different file-types.
     * @type {string}
     * @memberof UploadAttachmentBody
     */
    fileName?: string;
    /**
     * Send the file as base64 encoded. Note that base64 encoding files will increase the file size with about 30%
     * @type {string}
     * @memberof UploadAttachmentBody
     */
    fileContent?: string;
    /**
     * Url to document file. File must be available for download without any authorization
     * @type {string}
     * @memberof UploadAttachmentBody
     */
    fileUrl?: string;
}
/**
 * 
 * @export
 * @interface UploadAttachmentBody1
 */
export interface UploadAttachmentBody1 {
    /**
     * Binary File
     * @type {Blob}
     * @memberof UploadAttachmentBody1
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface UploadBody
 */
export interface UploadBody {
    /**
     * Filename of the document, with the extension. This will be helpful for converting different file-types.
     * @type {string}
     * @memberof UploadBody
     */
    fileName?: string;
    /**
     * Send the file as base64 encoded. Note that base64 encoding files will increase the file size with about 30%
     * @type {string}
     * @memberof UploadBody
     */
    fileContent?: string;
    /**
     * Url to document file. File must be available for download without any authorization
     * @type {string}
     * @memberof UploadBody
     */
    fileUrl?: string;
}
/**
 * 
 * @export
 * @interface UploadBody1
 */
export interface UploadBody1 {
    /**
     * Binary File
     * @type {Blob}
     * @memberof UploadBody1
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface UploadVideoBody
 */
export interface UploadVideoBody {
    /**
     * Filename of the document, with the extension. This will be helpful for converting different file-types.
     * @type {string}
     * @memberof UploadVideoBody
     */
    fileName?: string;
    /**
     * Send the file as base64 encoded. Note that base64 encoding files will increase the file size with about 30%
     * @type {string}
     * @memberof UploadVideoBody
     */
    fileContent?: string;
    /**
     * Url to document file. File must be available for download without any authorization
     * @type {string}
     * @memberof UploadVideoBody
     */
    fileUrl?: string;
}
/**
 * 
 * @export
 * @interface UploadVideoBody1
 */
export interface UploadVideoBody1 {
    /**
     * Binary File
     * @type {Blob}
     * @memberof UploadVideoBody1
     */
    file?: Blob;
}
/**
 * A user is defined by it´s e-mail address and is connected to one or many entities.  ### User Roles  #### Administrator: - View all documents - Edit all documents - Change entity settings, info and billing - Add new users to the entity - Assign entity roles  #### Manager: - View team documents - Edit all documents - Add new users to the entity  ## Entity An entity is the top node and all users and corresponding documents are connected to an entity. An entity is often the same as a company, a country or a department in a large organization. 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ID of the user
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * First name of the user
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * Last name of the user
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * Email address of the user
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * The title of the user, ex. CEO, Sales manager
     * @type {string}
     * @memberof User
     */
    title?: string;
    /**
     * Phone number in international format
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * Mobile number in international format
     * @type {string}
     * @memberof User
     */
    mobile?: string;
    /**
     * Optional internal note for user
     * @type {string}
     * @memberof User
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: User.RoleEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    teamId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    skipInvitation?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    thumbUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    entityId?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    entityName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    appMode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    disallowCreate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    status?: string;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        User = <any> 'user',
        Manager = <any> 'manager',
        Admin = <any> 'admin'
    }
}
/**
 * User list
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {Array<UsersUsers>}
     * @memberof Users
     */
    users?: Array<UsersUsers>;
}
/**
 * 
 * @export
 * @interface UsersBody
 */
export interface UsersBody {
    /**
     * Use to specify full name instead of first/last name
     * @type {string}
     * @memberof UsersBody
     */
    fullname?: string;
    /**
     * First name of the contact
     * @type {string}
     * @memberof UsersBody
     */
    firstName?: string;
    /**
     * Last name of the contact
     * @type {string}
     * @memberof UsersBody
     */
    lastName?: string;
    /**
     * Email address of the contact
     * @type {string}
     * @memberof UsersBody
     */
    email?: string;
    /**
     * The title of the contact, ex. CEO, Sales manager
     * @type {string}
     * @memberof UsersBody
     */
    title?: string;
    /**
     * Phone number in international format
     * @type {string}
     * @memberof UsersBody
     */
    phone?: string;
    /**
     * Mobile number in international format
     * @type {string}
     * @memberof UsersBody
     */
    mobile?: string;
    /**
     * Optional internal note for contact
     * @type {string}
     * @memberof UsersBody
     */
    note?: string;
    /**
     * Associated company name
     * @type {string}
     * @memberof UsersBody
     */
    companyName?: string;
    /**
     * Associated company number
     * @type {string}
     * @memberof UsersBody
     */
    companyNumber?: string;
}
/**
 * 
 * @export
 * @interface UsersUsers
 */
export interface UsersUsers {
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    teamName?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUsers
     */
    lastLogin?: string;
}
/**
 * Webhook payload
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    eventAction?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    subscriptionId?: string;
    /**
     * 
     * @type {Document}
     * @memberof Webhook
     */
    document?: Document;
    /**
     * 
     * @type {WebhookEntity}
     * @memberof Webhook
     */
    entity?: WebhookEntity;
    /**
     * 
     * @type {Recipient}
     * @memberof Webhook
     */
    recipient?: Recipient;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Webhook
     */
    customFields?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    event?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    eventType?: string;
}
/**
 * Entity for the webhook
 * @export
 * @interface WebhookEntity
 */
export interface WebhookEntity {
    /**
     * Default email message
     * @type {string}
     * @memberof WebhookEntity
     */
    emailSendMessage?: string;
    /**
     * Sub-domain for the entity
     * @type {string}
     * @memberof WebhookEntity
     */
    subDomain?: string;
    /**
     * Custom domain setting for entity
     * @type {string}
     * @memberof WebhookEntity
     */
    customDomain?: string;
    /**
     * Default email subject
     * @type {string}
     * @memberof WebhookEntity
     */
    emailSendSubject?: string;
}
/**
 * AttachmentsApi - fetch parameter creator
 * @export
 */
export const AttachmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Receive a list of available attachments. You can add new attachments in GetAccept using a new document.
         * @summary List attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachments(options: any = {}): FetchArgs {
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
         * @summary Upload an attachment
         * @param {UploadAttachmentBody} body A JSON object containing the uploaded attachment information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(body: UploadAttachmentBody, file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadAttachment.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadAttachment.');
            }
            const localVarPath = `/upload/attachment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"UploadAttachmentBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Receive a list of available attachments. You can add new attachments in GetAccept using a new document.
         * @summary List attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachments(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).listAttachments(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
         * @summary Upload an attachment
         * @param {UploadAttachmentBody} body A JSON object containing the uploaded attachment information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(body: UploadAttachmentBody, file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).uploadAttachment(body, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Receive a list of available attachments. You can add new attachments in GetAccept using a new document.
         * @summary List attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAttachments(options?: any) {
            return AttachmentsApiFp(configuration).listAttachments(options)(fetch, basePath);
        },
        /**
         * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
         * @summary Upload an attachment
         * @param {UploadAttachmentBody} body A JSON object containing the uploaded attachment information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(body: UploadAttachmentBody, file: Blob, options?: any) {
            return AttachmentsApiFp(configuration).uploadAttachment(body, file, options)(fetch, basePath);
        },
    };
};

/**
 * AttachmentsApi - interface
 * @export
 * @interface AttachmentsApi
 */
export interface AttachmentsApiInterface {
    /**
     * Receive a list of available attachments. You can add new attachments in GetAccept using a new document.
     * @summary List attachments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApiInterface
     */
    listAttachments(options?: any): Promise<InlineResponse20011>;

    /**
     * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
     * @summary Upload an attachment
     * @param {UploadAttachmentBody} body A JSON object containing the uploaded attachment information
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApiInterface
     */
    uploadAttachment(body: UploadAttachmentBody, file: Blob, options?: any): Promise<InlineResponse2009>;

}

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI implements AttachmentsApiInterface {
    /**
     * Receive a list of available attachments. You can add new attachments in GetAccept using a new document.
     * @summary List attachments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public listAttachments(options?: any) {
        return AttachmentsApiFp(this.configuration).listAttachments(options)(this.fetch, this.basePath);
    }

    /**
     * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
     * @summary Upload an attachment
     * @param {UploadAttachmentBody} body A JSON object containing the uploaded attachment information
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public uploadAttachment(body: UploadAttachmentBody, file: Blob, options?: any) {
        return AttachmentsApiFp(this.configuration).uploadAttachment(body, file, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Token based authentication is recommended for server-based access or access from clients where OAuth is not suitable. Access tokens has to be requested using an administrators login credentials. Requests should include the header Content-Type with value application/json
         * @summary Authentication by token
         * @param {AuthBody} body A JSON object containing authentication credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body: AuthBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authenticate.');
            }
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can request a refreshed of the access token before the original token has expired.
         * @summary Refresh an access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options: any = {}): FetchArgs {
            const localVarPath = `/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Token based authentication is recommended for server-based access or access from clients where OAuth is not suitable. Access tokens has to be requested using an administrators login credentials. Requests should include the header Content-Type with value application/json
         * @summary Authentication by token
         * @param {AuthBody} body A JSON object containing authentication credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body: AuthBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authenticate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can request a refreshed of the access token before the original token has expired.
         * @summary Refresh an access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).refreshToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Token based authentication is recommended for server-based access or access from clients where OAuth is not suitable. Access tokens has to be requested using an administrators login credentials. Requests should include the header Content-Type with value application/json
         * @summary Authentication by token
         * @param {AuthBody} body A JSON object containing authentication credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(body: AuthBody, options?: any) {
            return AuthenticationApiFp(configuration).authenticate(body, options)(fetch, basePath);
        },
        /**
         * You can request a refreshed of the access token before the original token has expired.
         * @summary Refresh an access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any) {
            return AuthenticationApiFp(configuration).refreshToken(options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * Token based authentication is recommended for server-based access or access from clients where OAuth is not suitable. Access tokens has to be requested using an administrators login credentials. Requests should include the header Content-Type with value application/json
     * @summary Authentication by token
     * @param {AuthBody} body A JSON object containing authentication credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authenticate(body: AuthBody, options?: any): Promise<InlineResponse200>;

    /**
     * You can request a refreshed of the access token before the original token has expired.
     * @summary Refresh an access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    refreshToken(options?: any): Promise<InlineResponse2001>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Token based authentication is recommended for server-based access or access from clients where OAuth is not suitable. Access tokens has to be requested using an administrators login credentials. Requests should include the header Content-Type with value application/json
     * @summary Authentication by token
     * @param {AuthBody} body A JSON object containing authentication credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(body: AuthBody, options?: any) {
        return AuthenticationApiFp(this.configuration).authenticate(body, options)(this.fetch, this.basePath);
    }

    /**
     * You can request a refreshed of the access token before the original token has expired.
     * @summary Refresh an access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshToken(options?: any) {
        return AuthenticationApiFp(this.configuration).refreshToken(options)(this.fetch, this.basePath);
    }

}
/**
 * ContactsApi - fetch parameter creator
 * @export
 */
export const ContactsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new contact in the database for the current entity
         * @summary Create contact
         * @param {ContactsBody} body A JSON object containing contact information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(body: ContactsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createContact.');
            }
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContactsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive a list of available contact for the current entity. All contacts added as a recipient are saved as a contact and is available for later use on that entity.
         * @summary List contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContacts(options: any = {}): FetchArgs {
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will create a new contact in the database for the current entity
         * @summary Create contact
         * @param {ContactsBody} body A JSON object containing contact information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(body: ContactsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).createContact(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Receive a list of available contact for the current entity. All contacts added as a recipient are saved as a contact and is available for later use on that entity.
         * @summary List contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContacts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contacts> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).listContacts(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This will create a new contact in the database for the current entity
         * @summary Create contact
         * @param {ContactsBody} body A JSON object containing contact information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(body: ContactsBody, options?: any) {
            return ContactsApiFp(configuration).createContact(body, options)(fetch, basePath);
        },
        /**
         * Receive a list of available contact for the current entity. All contacts added as a recipient are saved as a contact and is available for later use on that entity.
         * @summary List contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContacts(options?: any) {
            return ContactsApiFp(configuration).listContacts(options)(fetch, basePath);
        },
    };
};

/**
 * ContactsApi - interface
 * @export
 * @interface ContactsApi
 */
export interface ContactsApiInterface {
    /**
     * This will create a new contact in the database for the current entity
     * @summary Create contact
     * @param {ContactsBody} body A JSON object containing contact information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiInterface
     */
    createContact(body: ContactsBody, options?: any): Promise<InlineResponse2007>;

    /**
     * Receive a list of available contact for the current entity. All contacts added as a recipient are saved as a contact and is available for later use on that entity.
     * @summary List contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiInterface
     */
    listContacts(options?: any): Promise<Contacts>;

}

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI implements ContactsApiInterface {
    /**
     * This will create a new contact in the database for the current entity
     * @summary Create contact
     * @param {ContactsBody} body A JSON object containing contact information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public createContact(body: ContactsBody, options?: any) {
        return ContactsApiFp(this.configuration).createContact(body, options)(this.fetch, this.basePath);
    }

    /**
     * Receive a list of available contact for the current entity. All contacts added as a recipient are saved as a contact and is available for later use on that entity.
     * @summary List contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public listContacts(options?: any) {
        return ContactsApiFp(this.configuration).listContacts(options)(this.fetch, this.basePath);
    }

}
/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You must create a document to be able to send it to a recipient. When creating a document you can refer to previously uploaded files with file_id or you can choose to create a document and upload the files in on API post. You can only upload ONE file when including a file in the create document POST.  Use either file_ids parameter to use existing uploaded file(s), file_content to send the document as base64 encoded string or do a multipart post with file parameter.  All recipients must have either a valid e-mail or a mobile number.  All events are recorded using requestor IP address. You can override this using header CLIENT_IP containing the end-users public IP address.
         * @summary Create and send document or template
         * @param {DocumentsBody} body A JSON object containing document information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument(body: DocumentsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDocument.');
            }
            const localVarPath = `/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Document file can always be downloaded but most likely you want to download it when it has status Signed.   You can select to receive a download-url or get the binary file.  The download URL is accessable 10 minutes after a request has been made.
         * @summary Download document
         * @param {string} documentId Document ID
         * @param {string} [direct] Return the binary file directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, direct?: string, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling downloadDocument.');
            }
            const localVarPath = `/documents/{documentId}/download`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            if (direct !== undefined) {
                localVarQueryParameter['direct'] = direct;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document details by specifying a document id.
         * @summary Get document details
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDetails(documentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling getDocumentDetails.');
            }
            const localVarPath = `/documents/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of fields for a document or template. Can be used both before and after a document has been signed.
         * @summary Get document fields
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentFields(documentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling listDocumentFields.');
            }
            const localVarPath = `/documents/{documentId}/fields`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of available documents
         * @summary List documents
         * @param {string} [filter] Filter list on status
         * @param {string} [sortBy] How to sort results
         * @param {string} [sortOrder] Sort order of results
         * @param {boolean} [showteam] Include documents from team members
         * @param {boolean} [showall] Include all documents from entity
         * @param {string} [externalId] An external ID is a custom field which can contain a unique record identifier from a system outside of GetAccept
         * @param {number} [offset] Start list from record x until limit
         * @param {number} [limit] Number of records to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(filter?: string, sortBy?: string, sortOrder?: string, showteam?: boolean, showall?: boolean, externalId?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (showteam !== undefined) {
                localVarQueryParameter['showteam'] = showteam;
            }

            if (showall !== undefined) {
                localVarQueryParameter['showall'] = showall;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of recipients for a specific document.
         * @summary Get document recipients
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipients(documentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling listRecipients.');
            }
            const localVarPath = `/documents/{documentId}/recipients`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you prefer to send the document manually you can use this method to seal the document. Do not use this method if you send the document automatically or if you use the send document method above.  This API call triggers the document seal action and can only be performed on documents with document_status = draft. The method will return individual access/signing links for each recipient.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sealing.
         * @summary Seal document
         * @param {string} documentId Document ID
         * @param {DocumentIdSealBody} [body] An optional JSON object containing seal information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sealDocument(documentId: string, body?: DocumentIdSealBody, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling sealDocument.');
            }
            const localVarPath = `/documents/{documentId}/seal`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentIdSealBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When you send a document via GetAccept, we deliver an email to all recipients, each containing a unique, secured link. This API call triggers the document send action and can only be performed on documents with document_status = draft. The document will be sent to recipients you provided when it was created.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sending.
         * @summary Send existing document
         * @param {string} documentId Document ID
         * @param {DocumentIdSendBody} [body] An optional JSON object containing sending information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDocument(documentId: string, body?: DocumentIdSendBody, options: any = {}): FetchArgs {
            // verify required parameter 'documentId' is not null or undefined
            if (documentId === null || documentId === undefined) {
                throw new RequiredError('documentId','Required parameter documentId was null or undefined when calling sendDocument.');
            }
            const localVarPath = `/documents/{documentId}/send`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentIdSendBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload one file at a time and get a file id. The file id is used to connect a file with a GetAccept document which is sent to recipients. If you want to upload mutliple files you run multiple POST. We only accept files up to 10 MB as default. Uploaded file need to be imported/added to a document within 48 hours after uploading.  We recommended you to upload PDF files in order to guarantee the same look when sent. Other file types can be converted, such as:  Mirosoft Office: doc, docx, xl, xls, xlsx, ppt, pptx Mac: numbers, key Images: jpg, jpeg, png Other: html, tex, csv
         * @summary Upload a document file
         * @param {UploadBody} body A JSON object containing the uploaded document information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(body: UploadBody, file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadDocument.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadDocument.');
            }
            const localVarPath = `/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"UploadBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * You must create a document to be able to send it to a recipient. When creating a document you can refer to previously uploaded files with file_id or you can choose to create a document and upload the files in on API post. You can only upload ONE file when including a file in the create document POST.  Use either file_ids parameter to use existing uploaded file(s), file_content to send the document as base64 encoded string or do a multipart post with file parameter.  All recipients must have either a valid e-mail or a mobile number.  All events are recorded using requestor IP address. You can override this using header CLIENT_IP containing the end-users public IP address.
         * @summary Create and send document or template
         * @param {DocumentsBody} body A JSON object containing document information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument(body: DocumentsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Document> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).createDocument(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Document file can always be downloaded but most likely you want to download it when it has status Signed.   You can select to receive a download-url or get the binary file.  The download URL is accessable 10 minutes after a request has been made.
         * @summary Download document
         * @param {string} documentId Document ID
         * @param {string} [direct] Return the binary file directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, direct?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).downloadDocument(documentId, direct, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get document details by specifying a document id.
         * @summary Get document details
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDetails(documentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Document> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).getDocumentDetails(documentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of fields for a document or template. Can be used both before and after a document has been signed.
         * @summary Get document fields
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentFields(documentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fields> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).listDocumentFields(documentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of available documents
         * @summary List documents
         * @param {string} [filter] Filter list on status
         * @param {string} [sortBy] How to sort results
         * @param {string} [sortOrder] Sort order of results
         * @param {boolean} [showteam] Include documents from team members
         * @param {boolean} [showall] Include all documents from entity
         * @param {string} [externalId] An external ID is a custom field which can contain a unique record identifier from a system outside of GetAccept
         * @param {number} [offset] Start list from record x until limit
         * @param {number} [limit] Number of records to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(filter?: string, sortBy?: string, sortOrder?: string, showteam?: boolean, showall?: boolean, externalId?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Documents> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).listDocuments(filter, sortBy, sortOrder, showteam, showall, externalId, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of recipients for a specific document.
         * @summary Get document recipients
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipients(documentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recipients> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).listRecipients(documentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If you prefer to send the document manually you can use this method to seal the document. Do not use this method if you send the document automatically or if you use the send document method above.  This API call triggers the document seal action and can only be performed on documents with document_status = draft. The method will return individual access/signing links for each recipient.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sealing.
         * @summary Seal document
         * @param {string} documentId Document ID
         * @param {DocumentIdSealBody} [body] An optional JSON object containing seal information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sealDocument(documentId: string, body?: DocumentIdSealBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recipients> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).sealDocument(documentId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When you send a document via GetAccept, we deliver an email to all recipients, each containing a unique, secured link. This API call triggers the document send action and can only be performed on documents with document_status = draft. The document will be sent to recipients you provided when it was created.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sending.
         * @summary Send existing document
         * @param {string} documentId Document ID
         * @param {DocumentIdSendBody} [body] An optional JSON object containing sending information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDocument(documentId: string, body?: DocumentIdSendBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Document> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).sendDocument(documentId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can upload one file at a time and get a file id. The file id is used to connect a file with a GetAccept document which is sent to recipients. If you want to upload mutliple files you run multiple POST. We only accept files up to 10 MB as default. Uploaded file need to be imported/added to a document within 48 hours after uploading.  We recommended you to upload PDF files in order to guarantee the same look when sent. Other file types can be converted, such as:  Mirosoft Office: doc, docx, xl, xls, xlsx, ppt, pptx Mac: numbers, key Images: jpg, jpeg, png Other: html, tex, csv
         * @summary Upload a document file
         * @param {UploadBody} body A JSON object containing the uploaded document information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(body: UploadBody, file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).uploadDocument(body, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * You must create a document to be able to send it to a recipient. When creating a document you can refer to previously uploaded files with file_id or you can choose to create a document and upload the files in on API post. You can only upload ONE file when including a file in the create document POST.  Use either file_ids parameter to use existing uploaded file(s), file_content to send the document as base64 encoded string or do a multipart post with file parameter.  All recipients must have either a valid e-mail or a mobile number.  All events are recorded using requestor IP address. You can override this using header CLIENT_IP containing the end-users public IP address.
         * @summary Create and send document or template
         * @param {DocumentsBody} body A JSON object containing document information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument(body: DocumentsBody, options?: any) {
            return DocumentsApiFp(configuration).createDocument(body, options)(fetch, basePath);
        },
        /**
         * Document file can always be downloaded but most likely you want to download it when it has status Signed.   You can select to receive a download-url or get the binary file.  The download URL is accessable 10 minutes after a request has been made.
         * @summary Download document
         * @param {string} documentId Document ID
         * @param {string} [direct] Return the binary file directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, direct?: string, options?: any) {
            return DocumentsApiFp(configuration).downloadDocument(documentId, direct, options)(fetch, basePath);
        },
        /**
         * Get document details by specifying a document id.
         * @summary Get document details
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentDetails(documentId: string, options?: any) {
            return DocumentsApiFp(configuration).getDocumentDetails(documentId, options)(fetch, basePath);
        },
        /**
         * Get a list of fields for a document or template. Can be used both before and after a document has been signed.
         * @summary Get document fields
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentFields(documentId: string, options?: any) {
            return DocumentsApiFp(configuration).listDocumentFields(documentId, options)(fetch, basePath);
        },
        /**
         * Get a list of available documents
         * @summary List documents
         * @param {string} [filter] Filter list on status
         * @param {string} [sortBy] How to sort results
         * @param {string} [sortOrder] Sort order of results
         * @param {boolean} [showteam] Include documents from team members
         * @param {boolean} [showall] Include all documents from entity
         * @param {string} [externalId] An external ID is a custom field which can contain a unique record identifier from a system outside of GetAccept
         * @param {number} [offset] Start list from record x until limit
         * @param {number} [limit] Number of records to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(filter?: string, sortBy?: string, sortOrder?: string, showteam?: boolean, showall?: boolean, externalId?: string, offset?: number, limit?: number, options?: any) {
            return DocumentsApiFp(configuration).listDocuments(filter, sortBy, sortOrder, showteam, showall, externalId, offset, limit, options)(fetch, basePath);
        },
        /**
         * Get a list of recipients for a specific document.
         * @summary Get document recipients
         * @param {string} documentId Document ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipients(documentId: string, options?: any) {
            return DocumentsApiFp(configuration).listRecipients(documentId, options)(fetch, basePath);
        },
        /**
         * If you prefer to send the document manually you can use this method to seal the document. Do not use this method if you send the document automatically or if you use the send document method above.  This API call triggers the document seal action and can only be performed on documents with document_status = draft. The method will return individual access/signing links for each recipient.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sealing.
         * @summary Seal document
         * @param {string} documentId Document ID
         * @param {DocumentIdSealBody} [body] An optional JSON object containing seal information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sealDocument(documentId: string, body?: DocumentIdSealBody, options?: any) {
            return DocumentsApiFp(configuration).sealDocument(documentId, body, options)(fetch, basePath);
        },
        /**
         * When you send a document via GetAccept, we deliver an email to all recipients, each containing a unique, secured link. This API call triggers the document send action and can only be performed on documents with document_status = draft. The document will be sent to recipients you provided when it was created.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sending.
         * @summary Send existing document
         * @param {string} documentId Document ID
         * @param {DocumentIdSendBody} [body] An optional JSON object containing sending information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDocument(documentId: string, body?: DocumentIdSendBody, options?: any) {
            return DocumentsApiFp(configuration).sendDocument(documentId, body, options)(fetch, basePath);
        },
        /**
         * You can upload one file at a time and get a file id. The file id is used to connect a file with a GetAccept document which is sent to recipients. If you want to upload mutliple files you run multiple POST. We only accept files up to 10 MB as default. Uploaded file need to be imported/added to a document within 48 hours after uploading.  We recommended you to upload PDF files in order to guarantee the same look when sent. Other file types can be converted, such as:  Mirosoft Office: doc, docx, xl, xls, xlsx, ppt, pptx Mac: numbers, key Images: jpg, jpeg, png Other: html, tex, csv
         * @summary Upload a document file
         * @param {UploadBody} body A JSON object containing the uploaded document information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(body: UploadBody, file: Blob, options?: any) {
            return DocumentsApiFp(configuration).uploadDocument(body, file, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentsApi - interface
 * @export
 * @interface DocumentsApi
 */
export interface DocumentsApiInterface {
    /**
     * You must create a document to be able to send it to a recipient. When creating a document you can refer to previously uploaded files with file_id or you can choose to create a document and upload the files in on API post. You can only upload ONE file when including a file in the create document POST.  Use either file_ids parameter to use existing uploaded file(s), file_content to send the document as base64 encoded string or do a multipart post with file parameter.  All recipients must have either a valid e-mail or a mobile number.  All events are recorded using requestor IP address. You can override this using header CLIENT_IP containing the end-users public IP address.
     * @summary Create and send document or template
     * @param {DocumentsBody} body A JSON object containing document information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    createDocument(body: DocumentsBody, options?: any): Promise<Document>;

    /**
     * Document file can always be downloaded but most likely you want to download it when it has status Signed.   You can select to receive a download-url or get the binary file.  The download URL is accessable 10 minutes after a request has been made.
     * @summary Download document
     * @param {string} documentId Document ID
     * @param {string} [direct] Return the binary file directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadDocument(documentId: string, direct?: string, options?: any): Promise<InlineResponse2004>;

    /**
     * Get document details by specifying a document id.
     * @summary Get document details
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentDetails(documentId: string, options?: any): Promise<Document>;

    /**
     * Get a list of fields for a document or template. Can be used both before and after a document has been signed.
     * @summary Get document fields
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    listDocumentFields(documentId: string, options?: any): Promise<Fields>;

    /**
     * Get a list of available documents
     * @summary List documents
     * @param {string} [filter] Filter list on status
     * @param {string} [sortBy] How to sort results
     * @param {string} [sortOrder] Sort order of results
     * @param {boolean} [showteam] Include documents from team members
     * @param {boolean} [showall] Include all documents from entity
     * @param {string} [externalId] An external ID is a custom field which can contain a unique record identifier from a system outside of GetAccept
     * @param {number} [offset] Start list from record x until limit
     * @param {number} [limit] Number of records to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    listDocuments(filter?: string, sortBy?: string, sortOrder?: string, showteam?: boolean, showall?: boolean, externalId?: string, offset?: number, limit?: number, options?: any): Promise<Documents>;

    /**
     * Get a list of recipients for a specific document.
     * @summary Get document recipients
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    listRecipients(documentId: string, options?: any): Promise<Recipients>;

    /**
     * If you prefer to send the document manually you can use this method to seal the document. Do not use this method if you send the document automatically or if you use the send document method above.  This API call triggers the document seal action and can only be performed on documents with document_status = draft. The method will return individual access/signing links for each recipient.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sealing.
     * @summary Seal document
     * @param {string} documentId Document ID
     * @param {DocumentIdSealBody} [body] An optional JSON object containing seal information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    sealDocument(documentId: string, body?: DocumentIdSealBody, options?: any): Promise<Recipients>;

    /**
     * When you send a document via GetAccept, we deliver an email to all recipients, each containing a unique, secured link. This API call triggers the document send action and can only be performed on documents with document_status = draft. The document will be sent to recipients you provided when it was created.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sending.
     * @summary Send existing document
     * @param {string} documentId Document ID
     * @param {DocumentIdSendBody} [body] An optional JSON object containing sending information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    sendDocument(documentId: string, body?: DocumentIdSendBody, options?: any): Promise<Document>;

    /**
     * You can upload one file at a time and get a file id. The file id is used to connect a file with a GetAccept document which is sent to recipients. If you want to upload mutliple files you run multiple POST. We only accept files up to 10 MB as default. Uploaded file need to be imported/added to a document within 48 hours after uploading.  We recommended you to upload PDF files in order to guarantee the same look when sent. Other file types can be converted, such as:  Mirosoft Office: doc, docx, xl, xls, xlsx, ppt, pptx Mac: numbers, key Images: jpg, jpeg, png Other: html, tex, csv
     * @summary Upload a document file
     * @param {UploadBody} body A JSON object containing the uploaded document information
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadDocument(body: UploadBody, file: Blob, options?: any): Promise<InlineResponse2008>;

}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI implements DocumentsApiInterface {
    /**
     * You must create a document to be able to send it to a recipient. When creating a document you can refer to previously uploaded files with file_id or you can choose to create a document and upload the files in on API post. You can only upload ONE file when including a file in the create document POST.  Use either file_ids parameter to use existing uploaded file(s), file_content to send the document as base64 encoded string or do a multipart post with file parameter.  All recipients must have either a valid e-mail or a mobile number.  All events are recorded using requestor IP address. You can override this using header CLIENT_IP containing the end-users public IP address.
     * @summary Create and send document or template
     * @param {DocumentsBody} body A JSON object containing document information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createDocument(body: DocumentsBody, options?: any) {
        return DocumentsApiFp(this.configuration).createDocument(body, options)(this.fetch, this.basePath);
    }

    /**
     * Document file can always be downloaded but most likely you want to download it when it has status Signed.   You can select to receive a download-url or get the binary file.  The download URL is accessable 10 minutes after a request has been made.
     * @summary Download document
     * @param {string} documentId Document ID
     * @param {string} [direct] Return the binary file directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadDocument(documentId: string, direct?: string, options?: any) {
        return DocumentsApiFp(this.configuration).downloadDocument(documentId, direct, options)(this.fetch, this.basePath);
    }

    /**
     * Get document details by specifying a document id.
     * @summary Get document details
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocumentDetails(documentId: string, options?: any) {
        return DocumentsApiFp(this.configuration).getDocumentDetails(documentId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of fields for a document or template. Can be used both before and after a document has been signed.
     * @summary Get document fields
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public listDocumentFields(documentId: string, options?: any) {
        return DocumentsApiFp(this.configuration).listDocumentFields(documentId, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of available documents
     * @summary List documents
     * @param {string} [filter] Filter list on status
     * @param {string} [sortBy] How to sort results
     * @param {string} [sortOrder] Sort order of results
     * @param {boolean} [showteam] Include documents from team members
     * @param {boolean} [showall] Include all documents from entity
     * @param {string} [externalId] An external ID is a custom field which can contain a unique record identifier from a system outside of GetAccept
     * @param {number} [offset] Start list from record x until limit
     * @param {number} [limit] Number of records to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public listDocuments(filter?: string, sortBy?: string, sortOrder?: string, showteam?: boolean, showall?: boolean, externalId?: string, offset?: number, limit?: number, options?: any) {
        return DocumentsApiFp(this.configuration).listDocuments(filter, sortBy, sortOrder, showteam, showall, externalId, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of recipients for a specific document.
     * @summary Get document recipients
     * @param {string} documentId Document ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public listRecipients(documentId: string, options?: any) {
        return DocumentsApiFp(this.configuration).listRecipients(documentId, options)(this.fetch, this.basePath);
    }

    /**
     * If you prefer to send the document manually you can use this method to seal the document. Do not use this method if you send the document automatically or if you use the send document method above.  This API call triggers the document seal action and can only be performed on documents with document_status = draft. The method will return individual access/signing links for each recipient.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sealing.
     * @summary Seal document
     * @param {string} documentId Document ID
     * @param {DocumentIdSealBody} [body] An optional JSON object containing seal information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public sealDocument(documentId: string, body?: DocumentIdSealBody, options?: any) {
        return DocumentsApiFp(this.configuration).sealDocument(documentId, body, options)(this.fetch, this.basePath);
    }

    /**
     * When you send a document via GetAccept, we deliver an email to all recipients, each containing a unique, secured link. This API call triggers the document send action and can only be performed on documents with document_status = draft. The document will be sent to recipients you provided when it was created.  If document was created using self-sign option it will also be self-signed by the authenticated or specified user before sending.
     * @summary Send existing document
     * @param {string} documentId Document ID
     * @param {DocumentIdSendBody} [body] An optional JSON object containing sending information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public sendDocument(documentId: string, body?: DocumentIdSendBody, options?: any) {
        return DocumentsApiFp(this.configuration).sendDocument(documentId, body, options)(this.fetch, this.basePath);
    }

    /**
     * You can upload one file at a time and get a file id. The file id is used to connect a file with a GetAccept document which is sent to recipients. If you want to upload mutliple files you run multiple POST. We only accept files up to 10 MB as default. Uploaded file need to be imported/added to a document within 48 hours after uploading.  We recommended you to upload PDF files in order to guarantee the same look when sent. Other file types can be converted, such as:  Mirosoft Office: doc, docx, xl, xls, xlsx, ppt, pptx Mac: numbers, key Images: jpg, jpeg, png Other: html, tex, csv
     * @summary Upload a document file
     * @param {UploadBody} body A JSON object containing the uploaded document information
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploadDocument(body: UploadBody, file: Blob, options?: any) {
        return DocumentsApiFp(this.configuration).uploadDocument(body, file, options)(this.fetch, this.basePath);
    }

}
/**
 * OthersApi - fetch parameter creator
 * @export
 */
export const OthersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers when a document has been rejected by any of the recipients
         * @summary When a document has been rejected
         * @param {EventsRejectedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRejectedSubscription(body: EventsRejectedBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRejectedSubscription.');
            }
            const localVarPath = `/subscriptions/events/rejected`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventsRejectedBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers when a document has been reviewed by any of the recipients
         * @summary When a document has been reviewed
         * @param {EventsReviewedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewedSubscription(body: EventsReviewedBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createReviewedSubscription.');
            }
            const localVarPath = `/subscriptions/events/reviewed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventsReviewedBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers when a document has been signed by all signing parties
         * @summary When a document has been signed
         * @param {EventsSignedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedSubscription(body: EventsSignedBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSignedSubscription.');
            }
            const localVarPath = `/subscriptions/events/signed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventsSignedBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OthersApi - functional programming interface
 * @export
 */
export const OthersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Triggers when a document has been rejected by any of the recipients
         * @summary When a document has been rejected
         * @param {EventsRejectedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRejectedSubscription(body: EventsRejectedBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = OthersApiFetchParamCreator(configuration).createRejectedSubscription(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Triggers when a document has been reviewed by any of the recipients
         * @summary When a document has been reviewed
         * @param {EventsReviewedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewedSubscription(body: EventsReviewedBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = OthersApiFetchParamCreator(configuration).createReviewedSubscription(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Triggers when a document has been signed by all signing parties
         * @summary When a document has been signed
         * @param {EventsSignedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedSubscription(body: EventsSignedBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = OthersApiFetchParamCreator(configuration).createSignedSubscription(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OthersApi - factory interface
 * @export
 */
export const OthersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Triggers when a document has been rejected by any of the recipients
         * @summary When a document has been rejected
         * @param {EventsRejectedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRejectedSubscription(body: EventsRejectedBody, options?: any) {
            return OthersApiFp(configuration).createRejectedSubscription(body, options)(fetch, basePath);
        },
        /**
         * Triggers when a document has been reviewed by any of the recipients
         * @summary When a document has been reviewed
         * @param {EventsReviewedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReviewedSubscription(body: EventsReviewedBody, options?: any) {
            return OthersApiFp(configuration).createReviewedSubscription(body, options)(fetch, basePath);
        },
        /**
         * Triggers when a document has been signed by all signing parties
         * @summary When a document has been signed
         * @param {EventsSignedBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignedSubscription(body: EventsSignedBody, options?: any) {
            return OthersApiFp(configuration).createSignedSubscription(body, options)(fetch, basePath);
        },
    };
};

/**
 * OthersApi - interface
 * @export
 * @interface OthersApi
 */
export interface OthersApiInterface {
    /**
     * Triggers when a document has been rejected by any of the recipients
     * @summary When a document has been rejected
     * @param {EventsRejectedBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OthersApiInterface
     */
    createRejectedSubscription(body: EventsRejectedBody, options?: any): Promise<Subscription>;

    /**
     * Triggers when a document has been reviewed by any of the recipients
     * @summary When a document has been reviewed
     * @param {EventsReviewedBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OthersApiInterface
     */
    createReviewedSubscription(body: EventsReviewedBody, options?: any): Promise<Subscription>;

    /**
     * Triggers when a document has been signed by all signing parties
     * @summary When a document has been signed
     * @param {EventsSignedBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OthersApiInterface
     */
    createSignedSubscription(body: EventsSignedBody, options?: any): Promise<Subscription>;

}

/**
 * OthersApi - object-oriented interface
 * @export
 * @class OthersApi
 * @extends {BaseAPI}
 */
export class OthersApi extends BaseAPI implements OthersApiInterface {
    /**
     * Triggers when a document has been rejected by any of the recipients
     * @summary When a document has been rejected
     * @param {EventsRejectedBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OthersApi
     */
    public createRejectedSubscription(body: EventsRejectedBody, options?: any) {
        return OthersApiFp(this.configuration).createRejectedSubscription(body, options)(this.fetch, this.basePath);
    }

    /**
     * Triggers when a document has been reviewed by any of the recipients
     * @summary When a document has been reviewed
     * @param {EventsReviewedBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OthersApi
     */
    public createReviewedSubscription(body: EventsReviewedBody, options?: any) {
        return OthersApiFp(this.configuration).createReviewedSubscription(body, options)(this.fetch, this.basePath);
    }

    /**
     * Triggers when a document has been signed by all signing parties
     * @summary When a document has been signed
     * @param {EventsSignedBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OthersApi
     */
    public createSignedSubscription(body: EventsSignedBody, options?: any) {
        return OthersApiFp(this.configuration).createSignedSubscription(body, options)(this.fetch, this.basePath);
    }

}
/**
 * SubscriptionsApi - fetch parameter creator
 * @export
 */
export const SubscriptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call will create a new subscription. The response will be wrapped in an array even for single object according to REST hook standards.  >Events   * `document.created` - Document is created   * `document.sent` - Document is sent   * `document.viewed` - Document is sent   * `document.signed` - Document is signed   * `document.approved` - Document is approved   * `document.expired` - Document has expired   * `document.rejected` - Document is rejected   * `document.downloaded` - Document is downloaded   * `document.printed` - Document is printed   * `document.forwarded` - Document is forwarded   * `document.partially_signed` - Document has been partially signed   * `document.commented` - Document is commented   * `document.hardbounced` - Document is hardbounced   * `document.imported` - Document is imported
         * @summary Subscribe to document events
         * @param {SubscriptionsBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body: SubscriptionsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscription.');
            }
            const localVarPath = `/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a single subscription.
         * @summary Delete subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(subscriptionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling deleteSubscription.');
            }
            const localVarPath = `/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call will return details of a single subscription
         * @summary Get subscription details
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDetails(subscriptionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscriptionDetails.');
            }
            const localVarPath = `/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call will return a list of available subscription events
         * @summary List available subscription events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEvents(options: any = {}): FetchArgs {
            const localVarPath = `/subscriptions/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive a list of available subscriptions for the current entity.
         * @summary List subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(options: any = {}): FetchArgs {
            const localVarPath = `/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call will create a new subscription. The response will be wrapped in an array even for single object according to REST hook standards.  >Events   * `document.created` - Document is created   * `document.sent` - Document is sent   * `document.viewed` - Document is sent   * `document.signed` - Document is signed   * `document.approved` - Document is approved   * `document.expired` - Document has expired   * `document.rejected` - Document is rejected   * `document.downloaded` - Document is downloaded   * `document.printed` - Document is printed   * `document.forwarded` - Document is forwarded   * `document.partially_signed` - Document has been partially signed   * `document.commented` - Document is commented   * `document.hardbounced` - Document is hardbounced   * `document.imported` - Document is imported
         * @summary Subscribe to document events
         * @param {SubscriptionsBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body: SubscriptionsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).createSubscription(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a single subscription.
         * @summary Delete subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(subscriptionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).deleteSubscription(subscriptionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call will return details of a single subscription
         * @summary Get subscription details
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDetails(subscriptionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscription> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscriptionDetails(subscriptionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call will return a list of available subscription events
         * @summary List available subscription events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEvents(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2006>> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).listSubscriptionEvents(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Receive a list of available subscriptions for the current entity.
         * @summary List subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Subscriptions> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).listSubscriptions(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This call will create a new subscription. The response will be wrapped in an array even for single object according to REST hook standards.  >Events   * `document.created` - Document is created   * `document.sent` - Document is sent   * `document.viewed` - Document is sent   * `document.signed` - Document is signed   * `document.approved` - Document is approved   * `document.expired` - Document has expired   * `document.rejected` - Document is rejected   * `document.downloaded` - Document is downloaded   * `document.printed` - Document is printed   * `document.forwarded` - Document is forwarded   * `document.partially_signed` - Document has been partially signed   * `document.commented` - Document is commented   * `document.hardbounced` - Document is hardbounced   * `document.imported` - Document is imported
         * @summary Subscribe to document events
         * @param {SubscriptionsBody} body A JSON object containing subscription information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body: SubscriptionsBody, options?: any) {
            return SubscriptionsApiFp(configuration).createSubscription(body, options)(fetch, basePath);
        },
        /**
         * Delete a single subscription.
         * @summary Delete subscription
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(subscriptionId: string, options?: any) {
            return SubscriptionsApiFp(configuration).deleteSubscription(subscriptionId, options)(fetch, basePath);
        },
        /**
         * This call will return details of a single subscription
         * @summary Get subscription details
         * @param {string} subscriptionId Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDetails(subscriptionId: string, options?: any) {
            return SubscriptionsApiFp(configuration).getSubscriptionDetails(subscriptionId, options)(fetch, basePath);
        },
        /**
         * This call will return a list of available subscription events
         * @summary List available subscription events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEvents(options?: any) {
            return SubscriptionsApiFp(configuration).listSubscriptionEvents(options)(fetch, basePath);
        },
        /**
         * Receive a list of available subscriptions for the current entity.
         * @summary List subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(options?: any) {
            return SubscriptionsApiFp(configuration).listSubscriptions(options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionsApi - interface
 * @export
 * @interface SubscriptionsApi
 */
export interface SubscriptionsApiInterface {
    /**
     * This call will create a new subscription. The response will be wrapped in an array even for single object according to REST hook standards.  >Events   * `document.created` - Document is created   * `document.sent` - Document is sent   * `document.viewed` - Document is sent   * `document.signed` - Document is signed   * `document.approved` - Document is approved   * `document.expired` - Document has expired   * `document.rejected` - Document is rejected   * `document.downloaded` - Document is downloaded   * `document.printed` - Document is printed   * `document.forwarded` - Document is forwarded   * `document.partially_signed` - Document has been partially signed   * `document.commented` - Document is commented   * `document.hardbounced` - Document is hardbounced   * `document.imported` - Document is imported
     * @summary Subscribe to document events
     * @param {SubscriptionsBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    createSubscription(body: SubscriptionsBody, options?: any): Promise<Subscription>;

    /**
     * Delete a single subscription.
     * @summary Delete subscription
     * @param {string} subscriptionId Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    deleteSubscription(subscriptionId: string, options?: any): Promise<{}>;

    /**
     * This call will return details of a single subscription
     * @summary Get subscription details
     * @param {string} subscriptionId Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    getSubscriptionDetails(subscriptionId: string, options?: any): Promise<Subscription>;

    /**
     * This call will return a list of available subscription events
     * @summary List available subscription events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    listSubscriptionEvents(options?: any): Promise<Array<InlineResponse2006>>;

    /**
     * Receive a list of available subscriptions for the current entity.
     * @summary List subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    listSubscriptions(options?: any): Promise<Subscriptions>;

}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI implements SubscriptionsApiInterface {
    /**
     * This call will create a new subscription. The response will be wrapped in an array even for single object according to REST hook standards.  >Events   * `document.created` - Document is created   * `document.sent` - Document is sent   * `document.viewed` - Document is sent   * `document.signed` - Document is signed   * `document.approved` - Document is approved   * `document.expired` - Document has expired   * `document.rejected` - Document is rejected   * `document.downloaded` - Document is downloaded   * `document.printed` - Document is printed   * `document.forwarded` - Document is forwarded   * `document.partially_signed` - Document has been partially signed   * `document.commented` - Document is commented   * `document.hardbounced` - Document is hardbounced   * `document.imported` - Document is imported
     * @summary Subscribe to document events
     * @param {SubscriptionsBody} body A JSON object containing subscription information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createSubscription(body: SubscriptionsBody, options?: any) {
        return SubscriptionsApiFp(this.configuration).createSubscription(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a single subscription.
     * @summary Delete subscription
     * @param {string} subscriptionId Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public deleteSubscription(subscriptionId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).deleteSubscription(subscriptionId, options)(this.fetch, this.basePath);
    }

    /**
     * This call will return details of a single subscription
     * @summary Get subscription details
     * @param {string} subscriptionId Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionDetails(subscriptionId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionDetails(subscriptionId, options)(this.fetch, this.basePath);
    }

    /**
     * This call will return a list of available subscription events
     * @summary List available subscription events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionEvents(options?: any) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionEvents(options)(this.fetch, this.basePath);
    }

    /**
     * Receive a list of available subscriptions for the current entity.
     * @summary List subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptions(options?: any) {
        return SubscriptionsApiFp(this.configuration).listSubscriptions(options)(this.fetch, this.basePath);
    }

}
/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
export const TemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Receive a list of fields for a specific template.
         * @summary Get template fields
         * @param {string} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling listFields.');
            }
            const localVarPath = `/templates/{templateId}/fields`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive a list of roles for a specific template.
         * @summary Get template roles
         * @param {string} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling listRoles.');
            }
            const localVarPath = `/templates/{templateId}/roles`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive a list of available document templates. You can add new templates under the Templates-section in GetAccept.
         * @summary List templates
         * @param {string} [showall] Show all templates for entity
         * @param {string} [folderId] Show templates in a specific folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(showall?: string, folderId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            if (showall !== undefined) {
                localVarQueryParameter['showall'] = showall;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folder_id'] = folderId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Receive a list of fields for a specific template.
         * @summary Get template fields
         * @param {string} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(templateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fields> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).listFields(templateId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Receive a list of roles for a specific template.
         * @summary Get template roles
         * @param {string} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(templateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).listRoles(templateId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Receive a list of available document templates. You can add new templates under the Templates-section in GetAccept.
         * @summary List templates
         * @param {string} [showall] Show all templates for entity
         * @param {string} [folderId] Show templates in a specific folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(showall?: string, folderId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).listTemplates(showall, folderId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Receive a list of fields for a specific template.
         * @summary Get template fields
         * @param {string} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(templateId: string, options?: any) {
            return TemplatesApiFp(configuration).listFields(templateId, options)(fetch, basePath);
        },
        /**
         * Receive a list of roles for a specific template.
         * @summary Get template roles
         * @param {string} templateId Template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(templateId: string, options?: any) {
            return TemplatesApiFp(configuration).listRoles(templateId, options)(fetch, basePath);
        },
        /**
         * Receive a list of available document templates. You can add new templates under the Templates-section in GetAccept.
         * @summary List templates
         * @param {string} [showall] Show all templates for entity
         * @param {string} [folderId] Show templates in a specific folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(showall?: string, folderId?: string, options?: any) {
            return TemplatesApiFp(configuration).listTemplates(showall, folderId, options)(fetch, basePath);
        },
    };
};

/**
 * TemplatesApi - interface
 * @export
 * @interface TemplatesApi
 */
export interface TemplatesApiInterface {
    /**
     * Receive a list of fields for a specific template.
     * @summary Get template fields
     * @param {string} templateId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiInterface
     */
    listFields(templateId: string, options?: any): Promise<Fields>;

    /**
     * Receive a list of roles for a specific template.
     * @summary Get template roles
     * @param {string} templateId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiInterface
     */
    listRoles(templateId: string, options?: any): Promise<InlineResponse2005>;

    /**
     * Receive a list of available document templates. You can add new templates under the Templates-section in GetAccept.
     * @summary List templates
     * @param {string} [showall] Show all templates for entity
     * @param {string} [folderId] Show templates in a specific folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApiInterface
     */
    listTemplates(showall?: string, folderId?: string, options?: any): Promise<InlineResponse2002>;

}

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI implements TemplatesApiInterface {
    /**
     * Receive a list of fields for a specific template.
     * @summary Get template fields
     * @param {string} templateId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listFields(templateId: string, options?: any) {
        return TemplatesApiFp(this.configuration).listFields(templateId, options)(this.fetch, this.basePath);
    }

    /**
     * Receive a list of roles for a specific template.
     * @summary Get template roles
     * @param {string} templateId Template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listRoles(templateId: string, options?: any) {
        return TemplatesApiFp(this.configuration).listRoles(templateId, options)(this.fetch, this.basePath);
    }

    /**
     * Receive a list of available document templates. You can add new templates under the Templates-section in GetAccept.
     * @summary List templates
     * @param {string} [showall] Show all templates for entity
     * @param {string} [folderId] Show templates in a specific folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listTemplates(showall?: string, folderId?: string, options?: any) {
        return TemplatesApiFp(this.configuration).listTemplates(showall, folderId, options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will create a new contact in the database for the current entity
         * @summary Create user
         * @param {UsersBody} body A JSON object containing user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UsersBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call will return details of a single user. Receive details and available entities of the current authenticated user using user-id *me*
         * @summary Get user details
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserDetails.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of active users for the current authenticated entity
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will create a new contact in the database for the current entity
         * @summary Create user
         * @param {UsersBody} body A JSON object containing user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UsersBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call will return details of a single user. Receive details and available entities of the current authenticated user using user-id *me*
         * @summary Get user details
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserDetails(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of active users for the current authenticated entity
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Users> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This will create a new contact in the database for the current entity
         * @summary Create user
         * @param {UsersBody} body A JSON object containing user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UsersBody, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * This call will return details of a single user. Receive details and available entities of the current authenticated user using user-id *me*
         * @summary Get user details
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(userId: string, options?: any) {
            return UsersApiFp(configuration).getUserDetails(userId, options)(fetch, basePath);
        },
        /**
         * Fetch a list of active users for the current authenticated entity
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any) {
            return UsersApiFp(configuration).listUsers(options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * This will create a new contact in the database for the current entity
     * @summary Create user
     * @param {UsersBody} body A JSON object containing user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    createUser(body: UsersBody, options?: any): Promise<User>;

    /**
     * This call will return details of a single user. Receive details and available entities of the current authenticated user using user-id *me*
     * @summary Get user details
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserDetails(userId: string, options?: any): Promise<User>;

    /**
     * Fetch a list of active users for the current authenticated entity
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    listUsers(options?: any): Promise<Users>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * This will create a new contact in the database for the current entity
     * @summary Create user
     * @param {UsersBody} body A JSON object containing user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: UsersBody, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * This call will return details of a single user. Receive details and available entities of the current authenticated user using user-id *me*
     * @summary Get user details
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserDetails(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUserDetails(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of active users for the current authenticated entity
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: any) {
        return UsersApiFp(this.configuration).listUsers(options)(this.fetch, this.basePath);
    }

}
/**
 * VideosApi - fetch parameter creator
 * @export
 */
export const VideosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Receive a list of available videos on the entity. You can add new videos in the mobile app or inside GetAccept.
         * @summary List videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVideos(options: any = {}): FetchArgs {
            const localVarPath = `/videos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
         * @summary Upload a video
         * @param {UploadVideoBody} body A JSON object containing the uploaded video information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo(body: UploadVideoBody, file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadVideo.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadVideo.');
            }
            const localVarPath = `/upload/video`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("Oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication Token required

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"UploadVideoBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Receive a list of available videos on the entity. You can add new videos in the mobile app or inside GetAccept.
         * @summary List videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVideos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).listVideos(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
         * @summary Upload a video
         * @param {UploadVideoBody} body A JSON object containing the uploaded video information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo(body: UploadVideoBody, file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = VideosApiFetchParamCreator(configuration).uploadVideo(body, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Receive a list of available videos on the entity. You can add new videos in the mobile app or inside GetAccept.
         * @summary List videos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVideos(options?: any) {
            return VideosApiFp(configuration).listVideos(options)(fetch, basePath);
        },
        /**
         * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
         * @summary Upload a video
         * @param {UploadVideoBody} body A JSON object containing the uploaded video information
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo(body: UploadVideoBody, file: Blob, options?: any) {
            return VideosApiFp(configuration).uploadVideo(body, file, options)(fetch, basePath);
        },
    };
};

/**
 * VideosApi - interface
 * @export
 * @interface VideosApi
 */
export interface VideosApiInterface {
    /**
     * Receive a list of available videos on the entity. You can add new videos in the mobile app or inside GetAccept.
     * @summary List videos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    listVideos(options?: any): Promise<InlineResponse2003>;

    /**
     * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
     * @summary Upload a video
     * @param {UploadVideoBody} body A JSON object containing the uploaded video information
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    uploadVideo(body: UploadVideoBody, file: Blob, options?: any): Promise<InlineResponse20010>;

}

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI implements VideosApiInterface {
    /**
     * Receive a list of available videos on the entity. You can add new videos in the mobile app or inside GetAccept.
     * @summary List videos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public listVideos(options?: any) {
        return VideosApiFp(this.configuration).listVideos(options)(this.fetch, this.basePath);
    }

    /**
     * You can upload attachment files to include with documents you send. Successful request will return the attachment_id. Use attachment_id to assign an attachment to a document.
     * @summary Upload a video
     * @param {UploadVideoBody} body A JSON object containing the uploaded video information
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public uploadVideo(body: UploadVideoBody, file: Blob, options?: any) {
        return VideosApiFp(this.configuration).uploadVideo(body, file, options)(this.fetch, this.basePath);
    }

}
